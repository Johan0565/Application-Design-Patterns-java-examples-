# Паттерн проектирования: Состояние (State)

**Состояние** — это поведенческий паттерн, который позволяет объекту изменять свое поведение в зависимости от внутреннего состояния. Создается иллюзия, что объект сменил свой класс.



---

## Проблема
Если поведение объекта зависит от его статуса (например: *Сырая -> Готовится -> Готова*), код часто превращается в нагромождение проверок `if-else` или `switch`. Паттерн «Состояние» предлагает вынести логику каждого статуса в отдельный класс.

## Основные компоненты

### 1. Интерфейс состояния (State)
Определяет методы (действия), которые доступны для объекта. Каждое состояние реализует эти методы по-своему.
```java
interface State {
    void nextStep(ShawarmaOrder order); // Переход к следующему этапу
    void eat();                         // Попытка съесть
}
```

### 2. Контекст (ShawarmaOrder)
Объект, поведение которого должно меняться. Он хранит ссылку на текущий объект-состояние и делегирует ему выполнение методов.
```java
class ShawarmaOrder {
    private State currentState; // Текущий "мозг" заказа

    public void setState(State newState) {
        this.currentState = newState;
    }

    public void next() { currentState.nextStep(this); }
    public void eat()  { currentState.eat(); }
}
```

### 3. Конкретные состояния (RawState, CookingState, ReadyState)
Реализуют специфичное поведение. 
* **RawState**: позволяет начать готовку, но запрещает есть (выкидывает ошибку).
* **ReadyState**: позволяет съесть, но сообщает, что готовить дальше уже нельзя.

---

## Как это работает (Client)
1. Клиент создает контекст (`ShawarmaOrder`).
2. При вызове метода `next()`, текущее состояние выполняет свою логику и само переключает контекст на следующее состояние через `order.setState(...)`.
3. Поведение методов `eat()` или `next()` меняется автоматически "под капотом".

---

## Преимущества
* **Чистота (Single Responsibility):** Логика каждого состояния изолирована в своем классе.
* **Никаких огромных switch-кейсов:** Весь условный ветвистый код исчезает.
* **Безопасность:** Исключаются недопустимые переходы (например, нельзя съесть сырую шаурму, так как это прописано в `RawState`).

---
> **Важное отличие:** В отличие от паттерна **Стратегия**, состояния в **State** обычно знают о существовании друг друга и сами инициируют переходы между этапами.