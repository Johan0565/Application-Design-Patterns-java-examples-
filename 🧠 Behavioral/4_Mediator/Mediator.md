# Паттерн проектирования: Посредник (Mediator)

**Посредник** — это поведенческий паттерн проектирования, который ограничивает прямое взаимодействие между объектами и заставляет их сотрудничать через специальный объект-диспетчер.



---

## Проблема, которую мы решаем
Представь кухню ресторана: если кассир будет напрямую бегать к повару, повар — к официанту, а официант — обратно к кассиру, возникнет хаос из перепутанных связей (**Tight Coupling**). Если один сотрудник уволится или изменится, придется переписывать логику всех остальных.

**Посредник** превращает связи «все со всеми» в связи «один со всеми».

---

## Основные компоненты на основе кода

### 1. Интерфейс посредника (Mediator)
Описывает протокол общения. Компоненты не знают, *кто* именно получит сообщение, они просто говорят: «Эй, произошло вот это!».
```java
interface Mediator {
    void notify(Component sender, String event);
}
```

### 2. Компоненты / Коллеги (Components)
Это наши сотрудники (`Cashier`, `Chef`, `Waiter`). Главное правило: **они не знают о существовании друг друга**. У них есть только ссылка на «базу» (посредника).
```java
abstract class Component {
    protected Mediator mediator; // Ссылка на центр управления
    // ...
}

class Cashier extends Component {
    public void sendOrder() {
        System.out.println("Кассир: Заказ принят.");
        mediator.notify(this, "ORDER_PLACED"); // Уведомляем только посредника
    }
}
```

### 3. Конкретный посредник (Concrete Mediator)
Класс `RestaurantDispatcher` — это «мозг» системы. Он содержит всю бизнес-логику: кто должен начать работу, если кассир принял заказ.
```java
class RestaurantDispatcher implements Mediator {
    private Cashier cashier;
    private Chef chef;
    // ...

    @Override
    public void notify(Component sender, String event) {
        if (event.equals("ORDER_PLACED")) {
            chef.cook(); // Диспетчер знает, что теперь очередь повара
        } else if (event.equals("FOOD_READY")) {
            waiter.serve(); // Диспетчер знает, что пора нести еду
        }
    }
}
```

---

## Как это работает для клиента

В классе `Main` мы один раз связываем всех участников через диспетчера. Дальше система работает сама:

```java
// Кассир просто сообщает о событии, не заботясь о том, 
// есть ли повар на месте и как его зовут.
cashier.sendOrder(); 
```

---

## Преимущества использования
* **Слабая связанность (Loose Coupling):** Компоненты становятся максимально независимыми. Их легко переиспользовать в других проектах.
* **Упрощение взаимодействия:** Весь сложный код координации сосредоточен в одном месте (`RestaurantDispatcher`).
* **Легкость модификации:** Если в процесс нужно добавить «Уборщика» после того, как официант принес еду, мы меняем код только в Посреднике.

---
> **Важное замечание:** Не превращайте Посредника в «Божественный объект» (God Object), который знает слишком много и содержит абсолютно всю логику программы. Его задача — только координация сотрудников.